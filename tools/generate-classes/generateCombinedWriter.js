const fs = require("fs");
const path = require("path");

const getNameFromSchema = require("./getNameFromSchema");
const unindent = require("./unindent");

function generateCombinedWriter(options) {
  const { writerOutputDir, config, namespace, rootSchema, writers } = options;

  const name = getNameFromSchema(config, rootSchema);

  const header = `
        // This file was generated by generate-classes.
        // DO NOT EDIT THIS FILE!
        #pragma once

        #include <${namespace}/${name}.h>
        #include <CesiumJsonWriter/ExtensionWriterContext.h>
        #include <CesiumJsonWriter/JsonWriter.h>
        
        namespace Cesium3DTiles {

        ${writers
          .map((writer) => {
            return writer.writeDeclaration;
          })
          .join("\n")}
        
        } // namespace ${namespace}
  `;

  const implementation = `
        // This file was generated by generate-classes.
        // DO NOT EDIT THIS FILE!
        
        #include "${name}Writer.h"
        
        #include <CesiumJsonWriter/ExtensionWriterContext.h>
        #include <CesiumJsonWriter/ExtensionsWriter.h>
        #include <CesiumJsonWriter/JsonObjectWriter.h>
        #include <CesiumJsonWriter/JsonWriter.h>
        
        using namespace CesiumJsonWriter;
        using namespace CesiumUtility;
        
        namespace Cesium3DTiles {
        
        namespace {
        
        ${writers
          .map((writer) => {
            return writer.writeJsonDeclaration;
          })
          .join("\n")}
        
        [[maybe_unused]] void writeJson(
            const std::string& str,
            JsonWriter& jsonWriter,
            const ExtensionWriterContext& /* context */) {
          jsonWriter.String(str);
        }
        
        [[maybe_unused]] void writeJson(
            double val,
            JsonWriter& jsonWriter,
            const ExtensionWriterContext& /* context */) {
          jsonWriter.Double(val);
        }
        
        [[maybe_unused]] void writeJson(
            bool val,
            JsonWriter& jsonWriter,
            const ExtensionWriterContext& /* context */) {
          jsonWriter.Bool(val);
        }
        
        [[maybe_unused]] void writeJson(
            int64_t val,
            JsonWriter& jsonWriter,
            const ExtensionWriterContext& /* context */) {
          jsonWriter.Int64(val);
        }
        
        [[maybe_unused]] void writeJson(
            const JsonValue::Object& obj,
            JsonWriter& jsonWriter,
            const ExtensionWriterContext& /* context */) {
          jsonWriter.StartObject();
          for (const auto& item : obj) {
            jsonWriter.Key(item.first);
            writeJsonValue(item.second, jsonWriter);
          }
          jsonWriter.EndObject();
        }
        
        template <typename T>
        [[maybe_unused]] void writeJson(
            const std::vector<T>& list,
            JsonWriter& jsonWriter,
            const ExtensionWriterContext& context) {
          jsonWriter.StartArray();
          for (const T& item : list) {
            writeJson(item, jsonWriter, context);
          }
          jsonWriter.EndArray();
        }
        
        template <typename T>
        [[maybe_unused]] void writeJson(
            const std::optional<T>& val,
            JsonWriter& jsonWriter,
            const ExtensionWriterContext& context) {
          if (val.has_value()) {
            writeJson(*val, jsonWriter, context);
          } else {
            jsonWriter.Null();
          }
        }

        template <typename T>
        [[maybe_unused]] void writeJson(
            const std::unordered_map<std::string, T>& obj,
            JsonWriter& jsonWriter,
            const ExtensionWriterContext& context) {
          jsonWriter.StartObject();
          for (const auto& item : obj) {
            jsonWriter.Key(item.first);
            writeJson(item.second, jsonWriter, context);
          }
          jsonWriter.EndObject();
        }
        
        ${writers
          .map((writer) => {
            return writer.writeJsonDefinition;
          })
          .join("\n")}

        } // namespace

        ${writers
          .map((writer) => {
            return writer.writeDefinition;
          })
          .join("\n")}
        
        } // namespace Cesium3DTiles
  
  `;

  const headerOutputPath = path.join(
    writerOutputDir,
    "generated",
    `${name}Writer.h`
  );

  const implementationOutputPath = path.join(
    writerOutputDir,
    "generated",
    `${name}Writer.cpp`
  );

  fs.writeFileSync(headerOutputPath, unindent(header), "utf-8");
  fs.writeFileSync(implementationOutputPath, unindent(implementation), "utf-8");
}

module.exports = generateCombinedWriter;
