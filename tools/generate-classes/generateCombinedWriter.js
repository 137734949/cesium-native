const fs = require("fs");
const path = require("path");

const getNameFromSchema = require("./getNameFromSchema");
const unindent = require("./unindent");

function generateCombinedWriter(options) {
  const { writerOutputDir, config, namespace, rootSchema, writers, extensions } = options;

  const name = getNameFromSchema(config, rootSchema);

  const header = `
        // This file was generated by generate-classes.
        // DO NOT EDIT THIS FILE!
        #pragma once

        // forward declarations

        namespace CesiumJsonWriter {
          class JsonWriter;
          class ExtensionWriterContext;
        } // namespace CesiumJsonWriter

        namespace ${namespace} {
          ${writers
            .map((writer) => {
              return writer.writeForwardDeclaration;
            })
            .join("\n")}
        } // namespace ${namespace}

        namespace ${namespace} {

          void populateTilesetExtensions(CesiumJsonWriter::ExtensionWriterContext& context);
          
          ${writers
            .map((writer) => {
              return writer.writeDeclaration;
            })
            .join("\n")}
        
        } // namespace ${namespace}
  `;

  const implementation = `
        // This file was generated by generate-classes.
        // DO NOT EDIT THIS FILE!
        
        #include "${name}Writer.h"
        
        #include <CesiumJsonWriter/ExtensionWriterContext.h>
        #include <CesiumJsonWriter/writeJsonExtensions.h>
        #include <CesiumJsonWriter/JsonObjectWriter.h>
        #include <CesiumJsonWriter/JsonWriter.h>

        ${writers
          .map((writer) => {
            return writer.writeInclude;
          })
          .join("\n")}

        using namespace CesiumJsonWriter;
        using namespace CesiumUtility;
        
        namespace ${namespace} {
        
        namespace {
        
        ${writers
          .map((writer) => {
            return writer.writeJsonDeclaration;
          })
          .join("\n")}
        
        [[maybe_unused]] void writeJson(
            const std::string& str,
            JsonWriter& jsonWriter,
            const ExtensionWriterContext& /* context */) {
          jsonWriter.String(str);
        }
        
        [[maybe_unused]] void writeJson(
            double val,
            JsonWriter& jsonWriter,
            const ExtensionWriterContext& /* context */) {
          jsonWriter.Double(val);
        }
        
        [[maybe_unused]] void writeJson(
            bool val,
            JsonWriter& jsonWriter,
            const ExtensionWriterContext& /* context */) {
          jsonWriter.Bool(val);
        }
        
        [[maybe_unused]] void writeJson(
            int64_t val,
            JsonWriter& jsonWriter,
            const ExtensionWriterContext& /* context */) {
          jsonWriter.Int64(val);
        }
        
        [[maybe_unused]] void writeJson(
            const JsonValue::Object& obj,
            JsonWriter& jsonWriter,
            const ExtensionWriterContext& /* context */) {
          jsonWriter.StartObject();
          for (const auto& item : obj) {
            jsonWriter.Key(item.first);
            writeJsonValue(item.second, jsonWriter);
          }
          jsonWriter.EndObject();
        }
        
        template <typename T>
        [[maybe_unused]] void writeJson(
            const std::vector<T>& list,
            JsonWriter& jsonWriter,
            const ExtensionWriterContext& context) {
          jsonWriter.StartArray();
          for (const T& item : list) {
            writeJson(item, jsonWriter, context);
          }
          jsonWriter.EndArray();
        }
        
        template <typename T>
        [[maybe_unused]] void writeJson(
            const std::optional<T>& val,
            JsonWriter& jsonWriter,
            const ExtensionWriterContext& context) {
          if (val.has_value()) {
            writeJson(*val, jsonWriter, context);
          } else {
            jsonWriter.Null();
          }
        }

        template <typename T>
        [[maybe_unused]] void writeJson(
            const std::map<std::string, T>& obj,
            JsonWriter& jsonWriter,
            const ExtensionWriterContext& context) {
          jsonWriter.StartObject();
          for (const auto& item : obj) {
            jsonWriter.Key(item.first);
            writeJson(item.second, jsonWriter, context);
          }
          jsonWriter.EndObject();
        }
        
        ${writers
          .map((writer) => {
            return writer.writeJsonDefinition;
          })
          .join("\n")}

        } // namespace

        void populateTilesetExtensions(CesiumJsonWriter::ExtensionWriterContext& context) {
          ${extensions['Tileset']
            .map((extension) => {
              return `context.registerExtension<Tileset, ${extension.className}Writer>();`
            })
            .join("\n")}
        }


        ${writers
          .map((writer) => {
            return writer.writeDefinition;
          })
          .join("\n")}
        
        } // namespace ${namespace}
  
  `;

  const writerHeaderOutputDir = path.join(writerOutputDir, "generated", namespace);
  fs.mkdirSync(writerHeaderOutputDir, { recursive: true });

  const headerOutputPath = path.join(writerHeaderOutputDir, `${name}Writer.h`);

  const implementationOutputPath = path.join(
    writerHeaderOutputDir,
    `${name}Writer.cpp`
  );

  fs.writeFileSync(headerOutputPath, unindent(header), "utf-8");
  fs.writeFileSync(implementationOutputPath, unindent(implementation), "utf-8");
}

module.exports = generateCombinedWriter;
