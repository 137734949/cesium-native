// This file was generated by generate-gltf-classes.
// DO NOT EDIT THIS FILE!
#include "ModelEXT_feature_metadataJsonHandler.h"
#include "CesiumGltf/ModelEXT_feature_metadata.h"

#include <cassert>
#include <string>

using namespace CesiumGltf;

ModelEXT_feature_metadataJsonHandler::ModelEXT_feature_metadataJsonHandler(
    const ReaderContext& context) noexcept
    : ExtensibleObjectJsonHandler(context),
      _schema(context),
      _schemaUri(),
      _statistics(context),
      _featureTables(context),
      _featureTextures(context) {}

void ModelEXT_feature_metadataJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    ModelEXT_feature_metadata* pObject) {
  ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ModelEXT_feature_metadataJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyModelEXT_feature_metadata(
      ModelEXT_feature_metadata::TypeName,
      str,
      *this->_pObject);
}

void ModelEXT_feature_metadataJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    ExtensibleObject& o,
    const std::string_view& extensionName) {
  std::any& value =
      o.extensions.emplace(extensionName, ModelEXT_feature_metadata())
          .first->second;
  this->reset(
      pParentHandler,
      &std::any_cast<ModelEXT_feature_metadata&>(value));
}

CesiumJsonReader::IJsonHandler*
ModelEXT_feature_metadataJsonHandler::readObjectKeyModelEXT_feature_metadata(
    const std::string& objectType,
    const std::string_view& str,
    ModelEXT_feature_metadata& o) {
  using namespace std::string_literals;

  if ("schema"s == str)
    return property("schema", this->_schema, o.schema);
  if ("schemaUri"s == str)
    return property("schemaUri", this->_schemaUri, o.schemaUri);
  if ("statistics"s == str)
    return property("statistics", this->_statistics, o.statistics);
  if ("featureTables"s == str)
    return property("featureTables", this->_featureTables, o.featureTables);
  if ("featureTextures"s == str)
    return property(
        "featureTextures",
        this->_featureTextures,
        o.featureTextures);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}
