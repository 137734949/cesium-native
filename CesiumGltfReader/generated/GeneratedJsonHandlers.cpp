// This file was generated by generate-gltf-classes.
// DO NOT EDIT THIS FILE!
#include "CesiumGltf/KHR_draco_mesh_compression.h"
#include "KHR_draco_mesh_compressionJsonHandler.h"

#include <cassert>
#include <string>

using namespace CesiumGltf;

const char* KHR_draco_mesh_compressionJsonHandler::ExtensionName =
    "KHR_draco_mesh_compression";

KHR_draco_mesh_compressionJsonHandler::KHR_draco_mesh_compressionJsonHandler(
    const ReaderContext& context) noexcept
    : ExtensibleObjectJsonHandler(context), _bufferView(), _attributes() {}

void KHR_draco_mesh_compressionJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    KHR_draco_mesh_compression* pObject) {
  ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
KHR_draco_mesh_compressionJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyKHR_draco_mesh_compression(
      KHR_draco_mesh_compression::TypeName,
      str,
      *this->_pObject);
}

void KHR_draco_mesh_compressionJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    ExtensibleObject& o,
    const std::string_view& extensionName) {
  std::any& value =
      o.extensions.emplace(extensionName, KHR_draco_mesh_compression())
          .first->second;
  this->reset(
      pParentHandler,
      std::any_cast<KHR_draco_mesh_compression>(&value));
}

CesiumJsonReader::IJsonHandler*
KHR_draco_mesh_compressionJsonHandler::readObjectKeyKHR_draco_mesh_compression(
    const std::string& objectType,
    const std::string_view& str,
    KHR_draco_mesh_compression& o) {
  using namespace std::string_literals;

  if ("bufferView"s == str)
    return property("bufferView", this->_bufferView, o.bufferView);
  if ("attributes"s == str)
    return property("attributes", this->_attributes, o.attributes);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}
// This file was generated by generate-gltf-classes.
// DO NOT EDIT THIS FILE!
#include "CesiumGltf/Model.h"
#include "ModelJsonHandler.h"

#include <cassert>
#include <string>

using namespace CesiumGltf;

ModelJsonHandler::ModelJsonHandler(const ReaderContext& context) noexcept
    : ExtensibleObjectJsonHandler(context),
      _extensionsUsed(),
      _extensionsRequired(),
      _accessors(context),
      _animations(context),
      _asset(context),
      _buffers(context),
      _bufferViews(context),
      _cameras(context),
      _images(context),
      _materials(context),
      _meshes(context),
      _nodes(context),
      _samplers(context),
      _scene(),
      _scenes(context),
      _skins(context),
      _textures(context) {}

void ModelJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Model* pObject) {
  ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ModelJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyModel(Model::TypeName, str, *this->_pObject);
}

CesiumJsonReader::IJsonHandler* ModelJsonHandler::readObjectKeyModel(
    const std::string& objectType,
    const std::string_view& str,
    Model& o) {
  using namespace std::string_literals;

  if ("extensionsUsed"s == str)
    return property("extensionsUsed", this->_extensionsUsed, o.extensionsUsed);
  if ("extensionsRequired"s == str)
    return property(
        "extensionsRequired",
        this->_extensionsRequired,
        o.extensionsRequired);
  if ("accessors"s == str)
    return property("accessors", this->_accessors, o.accessors);
  if ("animations"s == str)
    return property("animations", this->_animations, o.animations);
  if ("asset"s == str)
    return property("asset", this->_asset, o.asset);
  if ("buffers"s == str)
    return property("buffers", this->_buffers, o.buffers);
  if ("bufferViews"s == str)
    return property("bufferViews", this->_bufferViews, o.bufferViews);
  if ("cameras"s == str)
    return property("cameras", this->_cameras, o.cameras);
  if ("images"s == str)
    return property("images", this->_images, o.images);
  if ("materials"s == str)
    return property("materials", this->_materials, o.materials);
  if ("meshes"s == str)
    return property("meshes", this->_meshes, o.meshes);
  if ("nodes"s == str)
    return property("nodes", this->_nodes, o.nodes);
  if ("samplers"s == str)
    return property("samplers", this->_samplers, o.samplers);
  if ("scene"s == str)
    return property("scene", this->_scene, o.scene);
  if ("scenes"s == str)
    return property("scenes", this->_scenes, o.scenes);
  if ("skins"s == str)
    return property("skins", this->_skins, o.skins);
  if ("textures"s == str)
    return property("textures", this->_textures, o.textures);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}
// This file was generated by generate-gltf-classes.
// DO NOT EDIT THIS FILE!
#include "CesiumGltf/Texture.h"
#include "TextureJsonHandler.h"

#include <cassert>
#include <string>

using namespace CesiumGltf;

TextureJsonHandler::TextureJsonHandler(const ReaderContext& context) noexcept
    : NamedObjectJsonHandler(context), _sampler(), _source() {}

void TextureJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Texture* pObject) {
  NamedObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
TextureJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyTexture(Texture::TypeName, str, *this->_pObject);
}

CesiumJsonReader::IJsonHandler* TextureJsonHandler::readObjectKeyTexture(
    const std::string& objectType,
    const std::string_view& str,
    Texture& o) {
  using namespace std::string_literals;

  if ("sampler"s == str)
    return property("sampler", this->_sampler, o.sampler);
  if ("source"s == str)
    return property("source", this->_source, o.source);

  return this->readObjectKeyNamedObject(objectType, str, *this->_pObject);
}
// This file was generated by generate-gltf-classes.
// DO NOT EDIT THIS FILE!
#include "CesiumGltf/Skin.h"
#include "SkinJsonHandler.h"

#include <cassert>
#include <string>

using namespace CesiumGltf;

SkinJsonHandler::SkinJsonHandler(const ReaderContext& context) noexcept
    : NamedObjectJsonHandler(context),
      _inverseBindMatrices(),
      _skeleton(),
      _joints() {}

void SkinJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Skin* pObject) {
  NamedObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
SkinJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeySkin(Skin::TypeName, str, *this->_pObject);
}

CesiumJsonReader::IJsonHandler* SkinJsonHandler::readObjectKeySkin(
    const std::string& objectType,
    const std::string_view& str,
    Skin& o) {
  using namespace std::string_literals;

  if ("inverseBindMatrices"s == str)
    return property(
        "inverseBindMatrices",
        this->_inverseBindMatrices,
        o.inverseBindMatrices);
  if ("skeleton"s == str)
    return property("skeleton", this->_skeleton, o.skeleton);
  if ("joints"s == str)
    return property("joints", this->_joints, o.joints);

  return this->readObjectKeyNamedObject(objectType, str, *this->_pObject);
}
// This file was generated by generate-gltf-classes.
// DO NOT EDIT THIS FILE!
#include "CesiumGltf/Scene.h"
#include "SceneJsonHandler.h"

#include <cassert>
#include <string>

using namespace CesiumGltf;

SceneJsonHandler::SceneJsonHandler(const ReaderContext& context) noexcept
    : NamedObjectJsonHandler(context), _nodes() {}

void SceneJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Scene* pObject) {
  NamedObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
SceneJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyScene(Scene::TypeName, str, *this->_pObject);
}

CesiumJsonReader::IJsonHandler* SceneJsonHandler::readObjectKeyScene(
    const std::string& objectType,
    const std::string_view& str,
    Scene& o) {
  using namespace std::string_literals;

  if ("nodes"s == str)
    return property("nodes", this->_nodes, o.nodes);

  return this->readObjectKeyNamedObject(objectType, str, *this->_pObject);
}
// This file was generated by generate-gltf-classes.
// DO NOT EDIT THIS FILE!
#include "CesiumGltf/Sampler.h"
#include "SamplerJsonHandler.h"

#include <cassert>
#include <string>

using namespace CesiumGltf;

SamplerJsonHandler::SamplerJsonHandler(const ReaderContext& context) noexcept
    : NamedObjectJsonHandler(context),
      _magFilter(),
      _minFilter(),
      _wrapS(),
      _wrapT() {}

void SamplerJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Sampler* pObject) {
  NamedObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
SamplerJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeySampler(Sampler::TypeName, str, *this->_pObject);
}

CesiumJsonReader::IJsonHandler* SamplerJsonHandler::readObjectKeySampler(
    const std::string& objectType,
    const std::string_view& str,
    Sampler& o) {
  using namespace std::string_literals;

  if ("magFilter"s == str)
    return property("magFilter", this->_magFilter, o.magFilter);
  if ("minFilter"s == str)
    return property("minFilter", this->_minFilter, o.minFilter);
  if ("wrapS"s == str)
    return property("wrapS", this->_wrapS, o.wrapS);
  if ("wrapT"s == str)
    return property("wrapT", this->_wrapT, o.wrapT);

  return this->readObjectKeyNamedObject(objectType, str, *this->_pObject);
}
// This file was generated by generate-gltf-classes.
// DO NOT EDIT THIS FILE!
#include "CesiumGltf/Node.h"
#include "NodeJsonHandler.h"

#include <cassert>
#include <string>

using namespace CesiumGltf;

NodeJsonHandler::NodeJsonHandler(const ReaderContext& context) noexcept
    : NamedObjectJsonHandler(context),
      _camera(),
      _children(),
      _skin(),
      _matrix(),
      _mesh(),
      _rotation(),
      _scale(),
      _translation(),
      _weights() {}

void NodeJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Node* pObject) {
  NamedObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
NodeJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyNode(Node::TypeName, str, *this->_pObject);
}

CesiumJsonReader::IJsonHandler* NodeJsonHandler::readObjectKeyNode(
    const std::string& objectType,
    const std::string_view& str,
    Node& o) {
  using namespace std::string_literals;

  if ("camera"s == str)
    return property("camera", this->_camera, o.camera);
  if ("children"s == str)
    return property("children", this->_children, o.children);
  if ("skin"s == str)
    return property("skin", this->_skin, o.skin);
  if ("matrix"s == str)
    return property("matrix", this->_matrix, o.matrix);
  if ("mesh"s == str)
    return property("mesh", this->_mesh, o.mesh);
  if ("rotation"s == str)
    return property("rotation", this->_rotation, o.rotation);
  if ("scale"s == str)
    return property("scale", this->_scale, o.scale);
  if ("translation"s == str)
    return property("translation", this->_translation, o.translation);
  if ("weights"s == str)
    return property("weights", this->_weights, o.weights);

  return this->readObjectKeyNamedObject(objectType, str, *this->_pObject);
}
// This file was generated by generate-gltf-classes.
// DO NOT EDIT THIS FILE!
#include "CesiumGltf/Mesh.h"
#include "MeshJsonHandler.h"

#include <cassert>
#include <string>

using namespace CesiumGltf;

MeshJsonHandler::MeshJsonHandler(const ReaderContext& context) noexcept
    : NamedObjectJsonHandler(context), _primitives(context), _weights() {}

void MeshJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Mesh* pObject) {
  NamedObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
MeshJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyMesh(Mesh::TypeName, str, *this->_pObject);
}

CesiumJsonReader::IJsonHandler* MeshJsonHandler::readObjectKeyMesh(
    const std::string& objectType,
    const std::string_view& str,
    Mesh& o) {
  using namespace std::string_literals;

  if ("primitives"s == str)
    return property("primitives", this->_primitives, o.primitives);
  if ("weights"s == str)
    return property("weights", this->_weights, o.weights);

  return this->readObjectKeyNamedObject(objectType, str, *this->_pObject);
}
// This file was generated by generate-gltf-classes.
// DO NOT EDIT THIS FILE!
#include "CesiumGltf/MeshPrimitive.h"
#include "MeshPrimitiveJsonHandler.h"

#include <cassert>
#include <string>

using namespace CesiumGltf;

MeshPrimitiveJsonHandler::MeshPrimitiveJsonHandler(
    const ReaderContext& context) noexcept
    : ExtensibleObjectJsonHandler(context),
      _attributes(),
      _indices(),
      _material(),
      _mode(),
      _targets() {}

void MeshPrimitiveJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    MeshPrimitive* pObject) {
  ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
MeshPrimitiveJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyMeshPrimitive(
      MeshPrimitive::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
MeshPrimitiveJsonHandler::readObjectKeyMeshPrimitive(
    const std::string& objectType,
    const std::string_view& str,
    MeshPrimitive& o) {
  using namespace std::string_literals;

  if ("attributes"s == str)
    return property("attributes", this->_attributes, o.attributes);
  if ("indices"s == str)
    return property("indices", this->_indices, o.indices);
  if ("material"s == str)
    return property("material", this->_material, o.material);
  if ("mode"s == str)
    return property("mode", this->_mode, o.mode);
  if ("targets"s == str)
    return property("targets", this->_targets, o.targets);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}
// This file was generated by generate-gltf-classes.
// DO NOT EDIT THIS FILE!
#include "CesiumGltf/Material.h"
#include "MaterialJsonHandler.h"

#include <cassert>
#include <string>

using namespace CesiumGltf;

MaterialJsonHandler::MaterialJsonHandler(const ReaderContext& context) noexcept
    : NamedObjectJsonHandler(context),
      _pbrMetallicRoughness(context),
      _normalTexture(context),
      _occlusionTexture(context),
      _emissiveTexture(context),
      _emissiveFactor(),
      _alphaMode(),
      _alphaCutoff(),
      _doubleSided() {}

void MaterialJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Material* pObject) {
  NamedObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
MaterialJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyMaterial(Material::TypeName, str, *this->_pObject);
}

CesiumJsonReader::IJsonHandler* MaterialJsonHandler::readObjectKeyMaterial(
    const std::string& objectType,
    const std::string_view& str,
    Material& o) {
  using namespace std::string_literals;

  if ("pbrMetallicRoughness"s == str)
    return property(
        "pbrMetallicRoughness",
        this->_pbrMetallicRoughness,
        o.pbrMetallicRoughness);
  if ("normalTexture"s == str)
    return property("normalTexture", this->_normalTexture, o.normalTexture);
  if ("occlusionTexture"s == str)
    return property(
        "occlusionTexture",
        this->_occlusionTexture,
        o.occlusionTexture);
  if ("emissiveTexture"s == str)
    return property(
        "emissiveTexture",
        this->_emissiveTexture,
        o.emissiveTexture);
  if ("emissiveFactor"s == str)
    return property("emissiveFactor", this->_emissiveFactor, o.emissiveFactor);
  if ("alphaMode"s == str)
    return property("alphaMode", this->_alphaMode, o.alphaMode);
  if ("alphaCutoff"s == str)
    return property("alphaCutoff", this->_alphaCutoff, o.alphaCutoff);
  if ("doubleSided"s == str)
    return property("doubleSided", this->_doubleSided, o.doubleSided);

  return this->readObjectKeyNamedObject(objectType, str, *this->_pObject);
}

void MaterialJsonHandler::AlphaModeJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParent,
    Material::AlphaMode* pEnum) {
  JsonHandler::reset(pParent);
  this->_pEnum = pEnum;
}

CesiumJsonReader::IJsonHandler*
MaterialJsonHandler::AlphaModeJsonHandler::readString(
    const std::string_view& str) {
  using namespace std::string_literals;

  assert(this->_pEnum);

  if ("OPAQUE"s == str)
    *this->_pEnum = Material::AlphaMode::OPAQUE;
  else if ("MASK"s == str)
    *this->_pEnum = Material::AlphaMode::MASK;
  else if ("BLEND"s == str)
    *this->_pEnum = Material::AlphaMode::BLEND;
  else
    return nullptr;

  return this->parent();
}
// This file was generated by generate-gltf-classes.
// DO NOT EDIT THIS FILE!
#include "CesiumGltf/TextureInfo.h"
#include "TextureInfoJsonHandler.h"

#include <cassert>
#include <string>

using namespace CesiumGltf;

TextureInfoJsonHandler::TextureInfoJsonHandler(
    const ReaderContext& context) noexcept
    : ExtensibleObjectJsonHandler(context), _index(), _texCoord() {}

void TextureInfoJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    TextureInfo* pObject) {
  ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
TextureInfoJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyTextureInfo(
      TextureInfo::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
TextureInfoJsonHandler::readObjectKeyTextureInfo(
    const std::string& objectType,
    const std::string_view& str,
    TextureInfo& o) {
  using namespace std::string_literals;

  if ("index"s == str)
    return property("index", this->_index, o.index);
  if ("texCoord"s == str)
    return property("texCoord", this->_texCoord, o.texCoord);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}
// This file was generated by generate-gltf-classes.
// DO NOT EDIT THIS FILE!
#include "CesiumGltf/MaterialOcclusionTextureInfo.h"
#include "MaterialOcclusionTextureInfoJsonHandler.h"

#include <cassert>
#include <string>

using namespace CesiumGltf;

MaterialOcclusionTextureInfoJsonHandler::
    MaterialOcclusionTextureInfoJsonHandler(
        const ReaderContext& context) noexcept
    : TextureInfoJsonHandler(context), _strength() {}

void MaterialOcclusionTextureInfoJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    MaterialOcclusionTextureInfo* pObject) {
  TextureInfoJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
MaterialOcclusionTextureInfoJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyMaterialOcclusionTextureInfo(
      MaterialOcclusionTextureInfo::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* MaterialOcclusionTextureInfoJsonHandler::
    readObjectKeyMaterialOcclusionTextureInfo(
        const std::string& objectType,
        const std::string_view& str,
        MaterialOcclusionTextureInfo& o) {
  using namespace std::string_literals;

  if ("strength"s == str)
    return property("strength", this->_strength, o.strength);

  return this->readObjectKeyTextureInfo(objectType, str, *this->_pObject);
}
// This file was generated by generate-gltf-classes.
// DO NOT EDIT THIS FILE!
#include "CesiumGltf/MaterialNormalTextureInfo.h"
#include "MaterialNormalTextureInfoJsonHandler.h"

#include <cassert>
#include <string>

using namespace CesiumGltf;

MaterialNormalTextureInfoJsonHandler::MaterialNormalTextureInfoJsonHandler(
    const ReaderContext& context) noexcept
    : TextureInfoJsonHandler(context), _scale() {}

void MaterialNormalTextureInfoJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    MaterialNormalTextureInfo* pObject) {
  TextureInfoJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
MaterialNormalTextureInfoJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyMaterialNormalTextureInfo(
      MaterialNormalTextureInfo::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
MaterialNormalTextureInfoJsonHandler::readObjectKeyMaterialNormalTextureInfo(
    const std::string& objectType,
    const std::string_view& str,
    MaterialNormalTextureInfo& o) {
  using namespace std::string_literals;

  if ("scale"s == str)
    return property("scale", this->_scale, o.scale);

  return this->readObjectKeyTextureInfo(objectType, str, *this->_pObject);
}
// This file was generated by generate-gltf-classes.
// DO NOT EDIT THIS FILE!
#include "CesiumGltf/MaterialPBRMetallicRoughness.h"
#include "MaterialPBRMetallicRoughnessJsonHandler.h"

#include <cassert>
#include <string>

using namespace CesiumGltf;

MaterialPBRMetallicRoughnessJsonHandler::
    MaterialPBRMetallicRoughnessJsonHandler(
        const ReaderContext& context) noexcept
    : ExtensibleObjectJsonHandler(context),
      _baseColorFactor(),
      _baseColorTexture(context),
      _metallicFactor(),
      _roughnessFactor(),
      _metallicRoughnessTexture(context) {}

void MaterialPBRMetallicRoughnessJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    MaterialPBRMetallicRoughness* pObject) {
  ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
MaterialPBRMetallicRoughnessJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyMaterialPBRMetallicRoughness(
      MaterialPBRMetallicRoughness::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* MaterialPBRMetallicRoughnessJsonHandler::
    readObjectKeyMaterialPBRMetallicRoughness(
        const std::string& objectType,
        const std::string_view& str,
        MaterialPBRMetallicRoughness& o) {
  using namespace std::string_literals;

  if ("baseColorFactor"s == str)
    return property(
        "baseColorFactor",
        this->_baseColorFactor,
        o.baseColorFactor);
  if ("baseColorTexture"s == str)
    return property(
        "baseColorTexture",
        this->_baseColorTexture,
        o.baseColorTexture);
  if ("metallicFactor"s == str)
    return property("metallicFactor", this->_metallicFactor, o.metallicFactor);
  if ("roughnessFactor"s == str)
    return property(
        "roughnessFactor",
        this->_roughnessFactor,
        o.roughnessFactor);
  if ("metallicRoughnessTexture"s == str)
    return property(
        "metallicRoughnessTexture",
        this->_metallicRoughnessTexture,
        o.metallicRoughnessTexture);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}
// This file was generated by generate-gltf-classes.
// DO NOT EDIT THIS FILE!
#include "CesiumGltf/Image.h"
#include "ImageJsonHandler.h"

#include <cassert>
#include <string>

using namespace CesiumGltf;

ImageJsonHandler::ImageJsonHandler(const ReaderContext& context) noexcept
    : NamedObjectJsonHandler(context), _uri(), _mimeType(), _bufferView() {}

void ImageJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Image* pObject) {
  NamedObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ImageJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyImage(Image::TypeName, str, *this->_pObject);
}

CesiumJsonReader::IJsonHandler* ImageJsonHandler::readObjectKeyImage(
    const std::string& objectType,
    const std::string_view& str,
    Image& o) {
  using namespace std::string_literals;

  if ("uri"s == str)
    return property("uri", this->_uri, o.uri);
  if ("mimeType"s == str)
    return property("mimeType", this->_mimeType, o.mimeType);
  if ("bufferView"s == str)
    return property("bufferView", this->_bufferView, o.bufferView);

  return this->readObjectKeyNamedObject(objectType, str, *this->_pObject);
}

void ImageJsonHandler::MimeTypeJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParent,
    Image::MimeType* pEnum) {
  JsonHandler::reset(pParent);
  this->_pEnum = pEnum;
}

CesiumJsonReader::IJsonHandler*
ImageJsonHandler::MimeTypeJsonHandler::readString(const std::string_view& str) {
  using namespace std::string_literals;

  assert(this->_pEnum);

  if ("image/jpeg"s == str)
    *this->_pEnum = Image::MimeType::image_jpeg;
  else if ("image/png"s == str)
    *this->_pEnum = Image::MimeType::image_png;
  else
    return nullptr;

  return this->parent();
}
// This file was generated by generate-gltf-classes.
// DO NOT EDIT THIS FILE!
#include "CameraJsonHandler.h"
#include "CesiumGltf/Camera.h"

#include <cassert>
#include <string>

using namespace CesiumGltf;

CameraJsonHandler::CameraJsonHandler(const ReaderContext& context) noexcept
    : NamedObjectJsonHandler(context),
      _orthographic(context),
      _perspective(context),
      _type() {}

void CameraJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Camera* pObject) {
  NamedObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
CameraJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyCamera(Camera::TypeName, str, *this->_pObject);
}

CesiumJsonReader::IJsonHandler* CameraJsonHandler::readObjectKeyCamera(
    const std::string& objectType,
    const std::string_view& str,
    Camera& o) {
  using namespace std::string_literals;

  if ("orthographic"s == str)
    return property("orthographic", this->_orthographic, o.orthographic);
  if ("perspective"s == str)
    return property("perspective", this->_perspective, o.perspective);
  if ("type"s == str)
    return property("type", this->_type, o.type);

  return this->readObjectKeyNamedObject(objectType, str, *this->_pObject);
}

void CameraJsonHandler::TypeJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParent,
    Camera::Type* pEnum) {
  JsonHandler::reset(pParent);
  this->_pEnum = pEnum;
}

CesiumJsonReader::IJsonHandler*
CameraJsonHandler::TypeJsonHandler::readString(const std::string_view& str) {
  using namespace std::string_literals;

  assert(this->_pEnum);

  if ("perspective"s == str)
    *this->_pEnum = Camera::Type::perspective;
  else if ("orthographic"s == str)
    *this->_pEnum = Camera::Type::orthographic;
  else
    return nullptr;

  return this->parent();
}
// This file was generated by generate-gltf-classes.
// DO NOT EDIT THIS FILE!
#include "CameraPerspectiveJsonHandler.h"
#include "CesiumGltf/CameraPerspective.h"

#include <cassert>
#include <string>

using namespace CesiumGltf;

CameraPerspectiveJsonHandler::CameraPerspectiveJsonHandler(
    const ReaderContext& context) noexcept
    : ExtensibleObjectJsonHandler(context),
      _aspectRatio(),
      _yfov(),
      _zfar(),
      _znear() {}

void CameraPerspectiveJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CameraPerspective* pObject) {
  ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
CameraPerspectiveJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyCameraPerspective(
      CameraPerspective::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
CameraPerspectiveJsonHandler::readObjectKeyCameraPerspective(
    const std::string& objectType,
    const std::string_view& str,
    CameraPerspective& o) {
  using namespace std::string_literals;

  if ("aspectRatio"s == str)
    return property("aspectRatio", this->_aspectRatio, o.aspectRatio);
  if ("yfov"s == str)
    return property("yfov", this->_yfov, o.yfov);
  if ("zfar"s == str)
    return property("zfar", this->_zfar, o.zfar);
  if ("znear"s == str)
    return property("znear", this->_znear, o.znear);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}
// This file was generated by generate-gltf-classes.
// DO NOT EDIT THIS FILE!
#include "CameraOrthographicJsonHandler.h"
#include "CesiumGltf/CameraOrthographic.h"

#include <cassert>
#include <string>

using namespace CesiumGltf;

CameraOrthographicJsonHandler::CameraOrthographicJsonHandler(
    const ReaderContext& context) noexcept
    : ExtensibleObjectJsonHandler(context),
      _xmag(),
      _ymag(),
      _zfar(),
      _znear() {}

void CameraOrthographicJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CameraOrthographic* pObject) {
  ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
CameraOrthographicJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyCameraOrthographic(
      CameraOrthographic::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
CameraOrthographicJsonHandler::readObjectKeyCameraOrthographic(
    const std::string& objectType,
    const std::string_view& str,
    CameraOrthographic& o) {
  using namespace std::string_literals;

  if ("xmag"s == str)
    return property("xmag", this->_xmag, o.xmag);
  if ("ymag"s == str)
    return property("ymag", this->_ymag, o.ymag);
  if ("zfar"s == str)
    return property("zfar", this->_zfar, o.zfar);
  if ("znear"s == str)
    return property("znear", this->_znear, o.znear);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}
// This file was generated by generate-gltf-classes.
// DO NOT EDIT THIS FILE!
#include "BufferViewJsonHandler.h"
#include "CesiumGltf/BufferView.h"

#include <cassert>
#include <string>

using namespace CesiumGltf;

BufferViewJsonHandler::BufferViewJsonHandler(
    const ReaderContext& context) noexcept
    : NamedObjectJsonHandler(context),
      _buffer(),
      _byteOffset(),
      _byteLength(),
      _byteStride(),
      _target() {}

void BufferViewJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    BufferView* pObject) {
  NamedObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
BufferViewJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyBufferView(
      BufferView::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* BufferViewJsonHandler::readObjectKeyBufferView(
    const std::string& objectType,
    const std::string_view& str,
    BufferView& o) {
  using namespace std::string_literals;

  if ("buffer"s == str)
    return property("buffer", this->_buffer, o.buffer);
  if ("byteOffset"s == str)
    return property("byteOffset", this->_byteOffset, o.byteOffset);
  if ("byteLength"s == str)
    return property("byteLength", this->_byteLength, o.byteLength);
  if ("byteStride"s == str)
    return property("byteStride", this->_byteStride, o.byteStride);
  if ("target"s == str)
    return property("target", this->_target, o.target);

  return this->readObjectKeyNamedObject(objectType, str, *this->_pObject);
}
// This file was generated by generate-gltf-classes.
// DO NOT EDIT THIS FILE!
#include "BufferJsonHandler.h"
#include "CesiumGltf/Buffer.h"

#include <cassert>
#include <string>

using namespace CesiumGltf;

BufferJsonHandler::BufferJsonHandler(const ReaderContext& context) noexcept
    : NamedObjectJsonHandler(context), _uri(), _byteLength() {}

void BufferJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Buffer* pObject) {
  NamedObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
BufferJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyBuffer(Buffer::TypeName, str, *this->_pObject);
}

CesiumJsonReader::IJsonHandler* BufferJsonHandler::readObjectKeyBuffer(
    const std::string& objectType,
    const std::string_view& str,
    Buffer& o) {
  using namespace std::string_literals;

  if ("uri"s == str)
    return property("uri", this->_uri, o.uri);
  if ("byteLength"s == str)
    return property("byteLength", this->_byteLength, o.byteLength);

  return this->readObjectKeyNamedObject(objectType, str, *this->_pObject);
}
// This file was generated by generate-gltf-classes.
// DO NOT EDIT THIS FILE!
#include "AssetJsonHandler.h"
#include "CesiumGltf/Asset.h"

#include <cassert>
#include <string>

using namespace CesiumGltf;

AssetJsonHandler::AssetJsonHandler(const ReaderContext& context) noexcept
    : ExtensibleObjectJsonHandler(context),
      _copyright(),
      _generator(),
      _version(),
      _minVersion() {}

void AssetJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Asset* pObject) {
  ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
AssetJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyAsset(Asset::TypeName, str, *this->_pObject);
}

CesiumJsonReader::IJsonHandler* AssetJsonHandler::readObjectKeyAsset(
    const std::string& objectType,
    const std::string_view& str,
    Asset& o) {
  using namespace std::string_literals;

  if ("copyright"s == str)
    return property("copyright", this->_copyright, o.copyright);
  if ("generator"s == str)
    return property("generator", this->_generator, o.generator);
  if ("version"s == str)
    return property("version", this->_version, o.version);
  if ("minVersion"s == str)
    return property("minVersion", this->_minVersion, o.minVersion);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}
// This file was generated by generate-gltf-classes.
// DO NOT EDIT THIS FILE!
#include "AnimationJsonHandler.h"
#include "CesiumGltf/Animation.h"

#include <cassert>
#include <string>

using namespace CesiumGltf;

AnimationJsonHandler::AnimationJsonHandler(
    const ReaderContext& context) noexcept
    : NamedObjectJsonHandler(context), _channels(context), _samplers(context) {}

void AnimationJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Animation* pObject) {
  NamedObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
AnimationJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyAnimation(
      Animation::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* AnimationJsonHandler::readObjectKeyAnimation(
    const std::string& objectType,
    const std::string_view& str,
    Animation& o) {
  using namespace std::string_literals;

  if ("channels"s == str)
    return property("channels", this->_channels, o.channels);
  if ("samplers"s == str)
    return property("samplers", this->_samplers, o.samplers);

  return this->readObjectKeyNamedObject(objectType, str, *this->_pObject);
}
// This file was generated by generate-gltf-classes.
// DO NOT EDIT THIS FILE!
#include "AnimationSamplerJsonHandler.h"
#include "CesiumGltf/AnimationSampler.h"

#include <cassert>
#include <string>

using namespace CesiumGltf;

AnimationSamplerJsonHandler::AnimationSamplerJsonHandler(
    const ReaderContext& context) noexcept
    : ExtensibleObjectJsonHandler(context),
      _input(),
      _interpolation(),
      _output() {}

void AnimationSamplerJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    AnimationSampler* pObject) {
  ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
AnimationSamplerJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyAnimationSampler(
      AnimationSampler::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
AnimationSamplerJsonHandler::readObjectKeyAnimationSampler(
    const std::string& objectType,
    const std::string_view& str,
    AnimationSampler& o) {
  using namespace std::string_literals;

  if ("input"s == str)
    return property("input", this->_input, o.input);
  if ("interpolation"s == str)
    return property("interpolation", this->_interpolation, o.interpolation);
  if ("output"s == str)
    return property("output", this->_output, o.output);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

void AnimationSamplerJsonHandler::InterpolationJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParent,
    AnimationSampler::Interpolation* pEnum) {
  JsonHandler::reset(pParent);
  this->_pEnum = pEnum;
}

CesiumJsonReader::IJsonHandler*
AnimationSamplerJsonHandler::InterpolationJsonHandler::readString(
    const std::string_view& str) {
  using namespace std::string_literals;

  assert(this->_pEnum);

  if ("LINEAR"s == str)
    *this->_pEnum = AnimationSampler::Interpolation::LINEAR;
  else if ("STEP"s == str)
    *this->_pEnum = AnimationSampler::Interpolation::STEP;
  else if ("CUBICSPLINE"s == str)
    *this->_pEnum = AnimationSampler::Interpolation::CUBICSPLINE;
  else
    return nullptr;

  return this->parent();
}
// This file was generated by generate-gltf-classes.
// DO NOT EDIT THIS FILE!
#include "AnimationChannelJsonHandler.h"
#include "CesiumGltf/AnimationChannel.h"

#include <cassert>
#include <string>

using namespace CesiumGltf;

AnimationChannelJsonHandler::AnimationChannelJsonHandler(
    const ReaderContext& context) noexcept
    : ExtensibleObjectJsonHandler(context), _sampler(), _target(context) {}

void AnimationChannelJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    AnimationChannel* pObject) {
  ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
AnimationChannelJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyAnimationChannel(
      AnimationChannel::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
AnimationChannelJsonHandler::readObjectKeyAnimationChannel(
    const std::string& objectType,
    const std::string_view& str,
    AnimationChannel& o) {
  using namespace std::string_literals;

  if ("sampler"s == str)
    return property("sampler", this->_sampler, o.sampler);
  if ("target"s == str)
    return property("target", this->_target, o.target);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}
// This file was generated by generate-gltf-classes.
// DO NOT EDIT THIS FILE!
#include "AnimationChannelTargetJsonHandler.h"
#include "CesiumGltf/AnimationChannelTarget.h"

#include <cassert>
#include <string>

using namespace CesiumGltf;

AnimationChannelTargetJsonHandler::AnimationChannelTargetJsonHandler(
    const ReaderContext& context) noexcept
    : ExtensibleObjectJsonHandler(context), _node(), _path() {}

void AnimationChannelTargetJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    AnimationChannelTarget* pObject) {
  ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
AnimationChannelTargetJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyAnimationChannelTarget(
      AnimationChannelTarget::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
AnimationChannelTargetJsonHandler::readObjectKeyAnimationChannelTarget(
    const std::string& objectType,
    const std::string_view& str,
    AnimationChannelTarget& o) {
  using namespace std::string_literals;

  if ("node"s == str)
    return property("node", this->_node, o.node);
  if ("path"s == str)
    return property("path", this->_path, o.path);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

void AnimationChannelTargetJsonHandler::PathJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParent,
    AnimationChannelTarget::Path* pEnum) {
  JsonHandler::reset(pParent);
  this->_pEnum = pEnum;
}

CesiumJsonReader::IJsonHandler*
AnimationChannelTargetJsonHandler::PathJsonHandler::readString(
    const std::string_view& str) {
  using namespace std::string_literals;

  assert(this->_pEnum);

  if ("translation"s == str)
    *this->_pEnum = AnimationChannelTarget::Path::translation;
  else if ("rotation"s == str)
    *this->_pEnum = AnimationChannelTarget::Path::rotation;
  else if ("scale"s == str)
    *this->_pEnum = AnimationChannelTarget::Path::scale;
  else if ("weights"s == str)
    *this->_pEnum = AnimationChannelTarget::Path::weights;
  else
    return nullptr;

  return this->parent();
}
// This file was generated by generate-gltf-classes.
// DO NOT EDIT THIS FILE!
#include "AccessorJsonHandler.h"
#include "CesiumGltf/Accessor.h"

#include <cassert>
#include <string>

using namespace CesiumGltf;

AccessorJsonHandler::AccessorJsonHandler(const ReaderContext& context) noexcept
    : NamedObjectJsonHandler(context),
      _bufferView(),
      _byteOffset(),
      _componentType(),
      _normalized(),
      _count(),
      _type(),
      _max(),
      _min(),
      _sparse(context) {}

void AccessorJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Accessor* pObject) {
  NamedObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
AccessorJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyAccessor(Accessor::TypeName, str, *this->_pObject);
}

CesiumJsonReader::IJsonHandler* AccessorJsonHandler::readObjectKeyAccessor(
    const std::string& objectType,
    const std::string_view& str,
    Accessor& o) {
  using namespace std::string_literals;

  if ("bufferView"s == str)
    return property("bufferView", this->_bufferView, o.bufferView);
  if ("byteOffset"s == str)
    return property("byteOffset", this->_byteOffset, o.byteOffset);
  if ("componentType"s == str)
    return property("componentType", this->_componentType, o.componentType);
  if ("normalized"s == str)
    return property("normalized", this->_normalized, o.normalized);
  if ("count"s == str)
    return property("count", this->_count, o.count);
  if ("type"s == str)
    return property("type", this->_type, o.type);
  if ("max"s == str)
    return property("max", this->_max, o.max);
  if ("min"s == str)
    return property("min", this->_min, o.min);
  if ("sparse"s == str)
    return property("sparse", this->_sparse, o.sparse);

  return this->readObjectKeyNamedObject(objectType, str, *this->_pObject);
}

void AccessorJsonHandler::TypeJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParent,
    Accessor::Type* pEnum) {
  JsonHandler::reset(pParent);
  this->_pEnum = pEnum;
}

CesiumJsonReader::IJsonHandler*
AccessorJsonHandler::TypeJsonHandler::readString(const std::string_view& str) {
  using namespace std::string_literals;

  assert(this->_pEnum);

  if ("SCALAR"s == str)
    *this->_pEnum = Accessor::Type::SCALAR;
  else if ("VEC2"s == str)
    *this->_pEnum = Accessor::Type::VEC2;
  else if ("VEC3"s == str)
    *this->_pEnum = Accessor::Type::VEC3;
  else if ("VEC4"s == str)
    *this->_pEnum = Accessor::Type::VEC4;
  else if ("MAT2"s == str)
    *this->_pEnum = Accessor::Type::MAT2;
  else if ("MAT3"s == str)
    *this->_pEnum = Accessor::Type::MAT3;
  else if ("MAT4"s == str)
    *this->_pEnum = Accessor::Type::MAT4;
  else
    return nullptr;

  return this->parent();
}
// This file was generated by generate-gltf-classes.
// DO NOT EDIT THIS FILE!
#include "AccessorSparseJsonHandler.h"
#include "CesiumGltf/AccessorSparse.h"

#include <cassert>
#include <string>

using namespace CesiumGltf;

AccessorSparseJsonHandler::AccessorSparseJsonHandler(
    const ReaderContext& context) noexcept
    : ExtensibleObjectJsonHandler(context),
      _count(),
      _indices(context),
      _values(context) {}

void AccessorSparseJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    AccessorSparse* pObject) {
  ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
AccessorSparseJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyAccessorSparse(
      AccessorSparse::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
AccessorSparseJsonHandler::readObjectKeyAccessorSparse(
    const std::string& objectType,
    const std::string_view& str,
    AccessorSparse& o) {
  using namespace std::string_literals;

  if ("count"s == str)
    return property("count", this->_count, o.count);
  if ("indices"s == str)
    return property("indices", this->_indices, o.indices);
  if ("values"s == str)
    return property("values", this->_values, o.values);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}
// This file was generated by generate-gltf-classes.
// DO NOT EDIT THIS FILE!
#include "AccessorSparseValuesJsonHandler.h"
#include "CesiumGltf/AccessorSparseValues.h"

#include <cassert>
#include <string>

using namespace CesiumGltf;

AccessorSparseValuesJsonHandler::AccessorSparseValuesJsonHandler(
    const ReaderContext& context) noexcept
    : ExtensibleObjectJsonHandler(context), _bufferView(), _byteOffset() {}

void AccessorSparseValuesJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    AccessorSparseValues* pObject) {
  ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
AccessorSparseValuesJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyAccessorSparseValues(
      AccessorSparseValues::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
AccessorSparseValuesJsonHandler::readObjectKeyAccessorSparseValues(
    const std::string& objectType,
    const std::string_view& str,
    AccessorSparseValues& o) {
  using namespace std::string_literals;

  if ("bufferView"s == str)
    return property("bufferView", this->_bufferView, o.bufferView);
  if ("byteOffset"s == str)
    return property("byteOffset", this->_byteOffset, o.byteOffset);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}
// This file was generated by generate-gltf-classes.
// DO NOT EDIT THIS FILE!
#include "AccessorSparseIndicesJsonHandler.h"
#include "CesiumGltf/AccessorSparseIndices.h"

#include <cassert>
#include <string>

using namespace CesiumGltf;

AccessorSparseIndicesJsonHandler::AccessorSparseIndicesJsonHandler(
    const ReaderContext& context) noexcept
    : ExtensibleObjectJsonHandler(context),
      _bufferView(),
      _byteOffset(),
      _componentType() {}

void AccessorSparseIndicesJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    AccessorSparseIndices* pObject) {
  ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
AccessorSparseIndicesJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyAccessorSparseIndices(
      AccessorSparseIndices::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
AccessorSparseIndicesJsonHandler::readObjectKeyAccessorSparseIndices(
    const std::string& objectType,
    const std::string_view& str,
    AccessorSparseIndices& o) {
  using namespace std::string_literals;

  if ("bufferView"s == str)
    return property("bufferView", this->_bufferView, o.bufferView);
  if ("byteOffset"s == str)
    return property("byteOffset", this->_byteOffset, o.byteOffset);
  if ("componentType"s == str)
    return property("componentType", this->_componentType, o.componentType);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}
