The cesium-native performance tracing framework is an alternative to a conventional sampling CPU profiler, such as the one built in to Visual Studio. It excels when you want to measure specific sections of code, and in particular where you want to measure the performance of a process that takes place _asynchronously_ across multiple threads. For example, we can measure the total time taken to load each tile in a 3D Tiles tileset, as well as how the total time is spent doing network requests, waiting for work to be dispatched to a thread pool, parsing the tile's glTF, etc. We can look at the minimum, maximum, average, standard deviation, etc. time taken for some or all of this process.

A conventional profiler would do a good (perhaps better!) job of measuring where CPU time is spent, and is absolutely the right tool to use for many optimization tasks. The cesium-native tracing framework, however, makes it easy add measurements for certain parts of a process that may or may not involve much time spent doing work on the CPU, such as the network requests mentioned previously. A sampling profiler can tell you where the CPU spent its time. The cesium-native tracing framework, in contrast, can tell you how long it took to perform various parts of a sequential process across threads.

