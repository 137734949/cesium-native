// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "SubtreeJsonHandler.h"

#include <Cesium3DTiles/Subtree.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

SubtreeJsonHandler::SubtreeJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _buffers(context),
      _bufferViews(context),
      _tileAvailability(context),
      _childSubtreeAvailability(context),
      _contentAvailability(context) {}

void SubtreeJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Subtree* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
SubtreeJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeySubtree(
      Cesium3DTiles::Subtree::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* SubtreeJsonHandler::readObjectKeySubtree(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::Subtree& o) {
  using namespace std::string_literals;

  if ("buffers"s == str)
    return property("buffers", this->_buffers, o.buffers);
  if ("bufferViews"s == str)
    return property("bufferViews", this->_bufferViews, o.bufferViews);
  if ("tileAvailability"s == str)
    return property(
        "tileAvailability",
        this->_tileAvailability,
        o.tileAvailability);
  if ("childSubtreeAvailability"s == str)
    return property(
        "childSubtreeAvailability",
        this->_childSubtreeAvailability,
        o.childSubtreeAvailability);
  if ("contentAvailability"s == str)
    return property(
        "contentAvailability",
        this->_contentAvailability,
        o.contentAvailability);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

void SubtreeJsonHandler::populateExtensions(
    CesiumJsonReader::ExtensionReaderContext& context) {
  (void)context;
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "AvailabilityJsonHandler.h"

#include <Cesium3DTiles/Availability.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

AvailabilityJsonHandler::AvailabilityJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _bufferView(),
      _availableCount(),
      _constant() {}

void AvailabilityJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Availability* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
AvailabilityJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyAvailability(
      Cesium3DTiles::Availability::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
AvailabilityJsonHandler::readObjectKeyAvailability(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::Availability& o) {
  using namespace std::string_literals;

  if ("bufferView"s == str)
    return property("bufferView", this->_bufferView, o.bufferView);
  if ("availableCount"s == str)
    return property("availableCount", this->_availableCount, o.availableCount);
  if ("constant"s == str)
    return property("constant", this->_constant, o.constant);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

void AvailabilityJsonHandler::populateExtensions(
    CesiumJsonReader::ExtensionReaderContext& context) {
  (void)context;
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "BufferViewJsonHandler.h"

#include <Cesium3DTiles/BufferView.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

BufferViewJsonHandler::BufferViewJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _buffer(),
      _byteOffset(),
      _byteLength(),
      _name() {}

void BufferViewJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::BufferView* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
BufferViewJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyBufferView(
      Cesium3DTiles::BufferView::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* BufferViewJsonHandler::readObjectKeyBufferView(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::BufferView& o) {
  using namespace std::string_literals;

  if ("buffer"s == str)
    return property("buffer", this->_buffer, o.buffer);
  if ("byteOffset"s == str)
    return property("byteOffset", this->_byteOffset, o.byteOffset);
  if ("byteLength"s == str)
    return property("byteLength", this->_byteLength, o.byteLength);
  if ("name"s == str)
    return property("name", this->_name, o.name);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

void BufferViewJsonHandler::populateExtensions(
    CesiumJsonReader::ExtensionReaderContext& context) {
  (void)context;
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "BufferJsonHandler.h"

#include <Cesium3DTiles/Buffer.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

BufferJsonHandler::BufferJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _uri(),
      _byteLength(),
      _name() {}

void BufferJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Buffer* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
BufferJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyBuffer(
      Cesium3DTiles::Buffer::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* BufferJsonHandler::readObjectKeyBuffer(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::Buffer& o) {
  using namespace std::string_literals;

  if ("uri"s == str)
    return property("uri", this->_uri, o.uri);
  if ("byteLength"s == str)
    return property("byteLength", this->_byteLength, o.byteLength);
  if ("name"s == str)
    return property("name", this->_name, o.name);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

void BufferJsonHandler::populateExtensions(
    CesiumJsonReader::ExtensionReaderContext& context) {
  (void)context;
}

} // namespace Cesium3DTilesReader
