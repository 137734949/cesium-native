// This file was generated by generate-gltf-classes.
// DO NOT EDIT THIS FILE!
#pragma once

#include "CesiumGltf/AccessorSparse.h"
#include "CesiumGltf/Library.h"
#include "CesiumGltf/NamedObject.h"
#include <cstdint>
#include <optional>
#include <vector>

namespace CesiumGltf {
/**
 * @brief A typed view into a bufferView.  A bufferView contains raw binary
 * data.  An accessor provides a typed view into a bufferView or a subset of a
 * bufferView similar to how WebGL's `vertexAttribPointer()` defines an
 * attribute in a buffer.
 */
struct CESIUMGLTF_API AccessorSpec : public NamedObject {
  static inline constexpr const char* TypeName = "Accessor";

  /**
   * @brief Known values for The datatype of components in the attribute.
   */
  struct ComponentType {
    static constexpr int32_t BYTE = 5120;

    static constexpr int32_t UNSIGNED_BYTE = 5121;

    static constexpr int32_t SHORT = 5122;

    static constexpr int32_t UNSIGNED_SHORT = 5123;

    static constexpr int32_t UNSIGNED_INT = 5125;

    static constexpr int32_t FLOAT = 5126;
  };

  /**
   * @brief Known values for Specifies if the attribute is a scalar, vector, or
   * matrix.
   */
  struct Type {
    inline static const std::string SCALAR = "SCALAR";

    inline static const std::string VEC2 = "VEC2";

    inline static const std::string VEC3 = "VEC3";

    inline static const std::string VEC4 = "VEC4";

    inline static const std::string MAT2 = "MAT2";

    inline static const std::string MAT3 = "MAT3";

    inline static const std::string MAT4 = "MAT4";
  };

  /**
   * @brief The index of the bufferView.
   *
   * When not defined, accessor must be initialized with zeros; `sparse`
   * property or extensions could override zeros with actual values.
   */
  int32_t bufferView = -1;

  /**
   * @brief The offset relative to the start of the bufferView in bytes.
   *
   * This must be a multiple of the size of the component datatype.
   */
  int64_t byteOffset = 0;

  /**
   * @brief The datatype of components in the attribute.
   *
   * Known values are defined in {@link ComponentType}.
   *
   *
   * All valid values correspond to WebGL enums.  The corresponding typed arrays
   * are `Int8Array`, `Uint8Array`, `Int16Array`, `Uint16Array`, `Uint32Array`,
   * and `Float32Array`, respectively.  5125 (UNSIGNED_INT) is only allowed when
   * the accessor contains indices, i.e., the accessor is only referenced by
   * `primitive.indices`.
   */
  int32_t componentType = int32_t();

  /**
   * @brief Specifies whether integer data values should be normalized.
   *
   * Specifies whether integer data values should be normalized (`true`) to [0,
   * 1] (for unsigned types) or [-1, 1] (for signed types), or converted
   * directly (`false`) when they are accessed. This property is defined only
   * for accessors that contain vertex attributes or animation output data.
   */
  bool normalized = false;

  /**
   * @brief The number of attributes referenced by this accessor.
   *
   * The number of attributes referenced by this accessor, not to be confused
   * with the number of bytes or number of components.
   */
  int64_t count = int64_t();

  /**
   * @brief Specifies if the attribute is a scalar, vector, or matrix.
   *
   * Known values are defined in {@link Type}.
   *
   */
  std::string type = std::string();

  /**
   * @brief Maximum value of each component in this attribute.
   *
   * Array elements must be treated as having the same data type as accessor's
   * `componentType`. Both min and max arrays have the same length.  The length
   * is determined by the value of the type property; it can be 1, 2, 3, 4, 9,
   * or 16.
   *
   * `normalized` property has no effect on array values: they always correspond
   * to the actual values stored in the buffer. When accessor is sparse, this
   * property must contain max values of accessor data with sparse substitution
   * applied.
   */
  std::vector<double> max;

  /**
   * @brief Minimum value of each component in this attribute.
   *
   * Array elements must be treated as having the same data type as accessor's
   * `componentType`. Both min and max arrays have the same length.  The length
   * is determined by the value of the type property; it can be 1, 2, 3, 4, 9,
   * or 16.
   *
   * `normalized` property has no effect on array values: they always correspond
   * to the actual values stored in the buffer. When accessor is sparse, this
   * property must contain min values of accessor data with sparse substitution
   * applied.
   */
  std::vector<double> min;

  /**
   * @brief Sparse storage of attributes that deviate from their initialization
   * value.
   */
  std::optional<AccessorSparse> sparse;

private:
  /**
   * @brief This class is not mean to be instantiated directly. Use {@link Accessor} instead.
   */
  AccessorSpec() = default;
  friend struct Accessor;
};
} // namespace CesiumGltf
